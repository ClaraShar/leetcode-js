# 110. 平衡二叉树

## 题目描述
给定一个二叉树，判断它是否是高度平衡的二叉树。
    
本题中，一棵高度平衡二叉树定义为：
    
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。
    
示例 1:
```
给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。
```
示例 2:
```
给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
```

## 解题思路
深搜递归，加强练习。

## 代码
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    if(!root){
        return true;
    }
    if(Math.abs(countDepth(root.left)-countDepth(root.right)) > 1){
        return false;
    }
    else{
        if(isBalanced(root.left) && isBalanced(root.right)){
            return true;
        }
        else{
            return false;
        }
    }
};

var countDepth = function(root) {
    if(!root){
        return 0;
    }
    return 1 + Math.max(countDepth(root.left), countDepth(root.right));
}
```

# 101. 对称二叉树

## 题目描述
给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```
但是下面这个[1,2,2,null,3,null,3] 则不是镜像对称的:
```
    1
   / \
  2   2
   \   \
   3    3  
```

## 解题思路
递归深搜左右子树，看是否相等。

## 代码
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    if(!root){
        return false;
    }
    return DFS(root, root);
};

var DFS = function(tree1, tree2){
    if(!tree1 && !tree2){
        return true;
    }
    if(!tree1 || !tree2){
        return false;
    }
    return (tree1.val == tree2.val && DFS(tree1.left, tree2.right) && DFS(tree2.left, tree1.right));
}
```

# 226. 翻转二叉树

## 题目描述
翻转一棵二叉树。

示例：

输入：
```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```
输出：
```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

## 解题思路
递归解题思路是对的，但是细节有问题，所以参考了一下题解。
交换顺序应该是自底向上的，递归到叶子结点进行交换再往上走。
这里的节点交换不只是值交换，是交换整个树节点，mark一下，以后要搞清楚。

## 代码
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if(!root){
        return root;
    }
    invertTree(root.left);
    invertTree(root.right);
    [root.left, root.right] = [root.right, root.left];//新技能get
    return root;
};
```

# 617. 合并二叉树

## 题目描述
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例:
输入: 
```
    Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
```
输出: 
合并后的树:
```
         3
        / \
       4   5
      / \   \ 
     5   4   7
```

## 解题思路
思路是对的，但是最开始自己的方法有点笨，后面参考了题解，可以直接把第二棵树加在第一棵树上，便捷操作。
另外，函数里没有判断root2为null的情况，故在递归的参数里加了对root2的约束。详见“//”处的代码

## 代码
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */
var mergeTrees = function(root1, root2) {
    if(!root1 && !root2)
        return null;
    if(!root1 && root2)
        return root1 = root2;
    if(root1 && root2)
        root1.val += root2.val;
    root1.left = mergeTrees(root1.left, root2 && root2.left);//
    root1.right = mergeTrees(root1.right, root2 && root2.right);//
    return root1;
};
```

# 剑指 Offer 07. 重建二叉树

## 题目描述
输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。


示例 1：
![avatar](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)
```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```
示例 2：
```
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

## 解题思路
跟二叉树有关都是递归思想。
前序是先遍历根结点（中左右），中序是左中右，所以前序的第一个元素就是树根，在中序中以树根元素划分左右子树。


## 代码
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    if(!preorder.length || !inorder.length) return null;
    let root = preorder[0]
    let rootIndex = inorder.indexOf(root)
    let node = new TreeNode(root)
    node.left = buildTree(preorder.slice(1,rootIndex+1),inorder.slice(0,rootIndex))
    node.right = buildTree(preorder.slice(rootIndex+1),inorder.slice(rootIndex+1))
    return node;
};
```

# 222. 完全二叉树的节点个数

## 题目描述
给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

示例：
![avatar](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)
```
输入：root = [1,2,3,4,5,6]
输出：6
```

## 解题思路
参考[题解](https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/js-3-chong-fang-fa-by-std5656-8o19/)
最简单的就是递归，遍历到你就+1

## 代码
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) {
    if (!root) return 0;
    return 1 + countNodes(root.left) + countNodes(root.right);
};
```

# 剑指 Offer 33. 二叉搜索树的后序遍历序列

## 题目描述
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。

参考以下这颗二叉搜索树：
```
     5
    / \
   2   6
  / \
 1   3
```

示例 1：
```
输入: [1,6,3,2,5]
输出: false
```
示例 2：
```
输入: [1,3,2,6,5]
输出: true
```

## 解题思路
牢记这句话：*跟二叉树有关都是递归思想。*
前序是先遍历根结点（中左右），中序是左中右，后序是左右中。所以后序最后一个元素就是树根。
还有一个关键：*在题目没有重复数字的前提下，二叉搜索树的左子树均小于根节点，右子树均大于根节点。*
所以只需要递归判断右子树是否均大于根节点。


## 代码
```
/**
 * @param {number[]} postorder
 * @return {boolean}
 */
var verifyPostorder = function(postorder) {
    var len = postorder.length;
    if(postorder.length < 2) return true;
    var root = postorder[len - 1]
    //划分左右子树
    var i = 0;
    for( ;i < len - 1; i++){
        if(postorder[i] > root) break;
    }
    // 判断右子树中的元素是否都大于 root，此处用到 every (数组 API，数组的每个元素都返回 true 则整体返回 true)
    var result = postorder.slice(i, len - 1).every(x => x > root)
    if(result){
        return(verifyPostorder(postorder.slice(0,i)) && verifyPostorder(postorder.slice(i,len - 1)))
    }else{
        return false;
    }
};
```

# 230. 二叉搜索树中第K小的元素

## 题目描述
给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。

示例：
![avatar](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)
```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

## 解题思路
1. 二叉搜索树的中序遍历结果是从小到大的顺序
2. 终止条件为k===0时，res为保存结果

## 代码
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
    let res = null
    function inorderTraversal(root) {
        if(root == null) return
        inorderTraversal(root.left)
        if(--k === 0) {
            res = root.val
            return res
        }
        inorderTraversal(root.right)
    }
    inorderTraversal(root)
    return res
};
```

# 236. 二叉树的最近公共祖先

## 题目描述
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

示例：
![avatar](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

## 解题思路
递归分为三种情况
1. pq分别在左右子树，直接return root
2. root = p或q 也是直接 return root
3. 递归左右子树，重复上面的判断
*这题不太好懂，Mark一下*


## 代码
```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if (root === null || root === p || root === q) {
        return root;
    }
    var left = lowestCommonAncestor(root.left, p, q);
    var right = lowestCommonAncestor(root.right, p, q);
    if (left === null) return right;
    if (right === null) return left;
    return root;
};
```