# 77. 组合

## 题目描述
给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

你可以按 任何顺序 返回答案。


示例：
```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
``` 

## 解题思路
还不太会操作JS的递归回溯方法。
JS函数的参数都是按值传递的。在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。这里复制的值实际上是一个指针，它指向存储在全局作用域的堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来。
所以要用slice解除数组的引用（创建一个新的副本）。

## 代码
```
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function(n, k) {
    if(k < 0) return []
    var result = []
    function dfs(n, track = [], current = 0) {
        if(track.length === k) {
            // slice 用于解除引用 比[...track]效率高
            result.push(track.slice())
            return
        }
        for (let i = current + 1; i <= n; i++) {//track里有[1]的时候，循环加入2，3，4
            track.push(i)
            dfs(n, track, i)
            track.pop()
        }
    }
    dfs(n)
    return result;
};
```

# 78. 子集

## 题目描述
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

示例：
```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
``` 

## 解题思路
和77组合一样的思想，循环+递归形成回溯。

## 代码
```
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    const result = []
    let track = []
    function dfs(nums, track, current){
        result.push(track.slice())
        for(let i = current; i < nums.length; i++){
            track.push(nums[i])
            dfs(nums, track, i+1)//比current多1
            track.pop()
        }
    }
    dfs(nums, track, 0)
    return result
};
```

# 90. 子集 II

## 题目描述
给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

示例：
```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
``` 

## 解题思路
这题刷的我心力交瘁。
参考：数组中会存在重复的元素 => 先排序，然后只组合相同元素的第一个元素
回溯一直搞不大清楚，mark

## 代码
```
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsetsWithDup = function(nums) {
    var result = []
    nums.sort((a,b) => a-b)
    let track = []
    function dfs(track, current) {
        result.push(track.slice())
        if(track.length === nums.length) return //所有元素都包含了
        for(let i = current; i < nums.length; i++){
            if (i > current && nums[i] === nums[i-1]) continue //关键！跳过重复元素
            track.push(nums[i])
            dfs(track,i+1)
            track.pop()
        }
    }
    dfs(track,0)
    return result
};

```